// Author: James Courtland Neuhaus <jneuhau1@vols.utk.edu>
// Update: 2017-05-31
// Copyright: 2017 (C) James Courtland Neuhaus
// For the licensing terms see $ROOTSYS/LICENSE.
//
//////////////////////////////////////////////////////////////
//
// This code compares two jets clustered using fastjet to pair them based on two criteria:
//   1) dR - the radial offset Sqrt(dEta^2 + dPhi^2)
//   2) Overlap - N_overlap/N_DetectorJet
//
// Jets are compared using a score from the following algorithm
//   X = (1-Overlap)*dR
//
// The lowest scored pair is matched and stored in the passed by reference Int_t vector
//
// Nomeclature:
//  Detector Level Jet - Jet clustered from MC particles excluding neutrals
//
// EXAMPLE:
//   RelatedParticleJetIndex[0] is the index of the detector level jet with index 0,
//   if the value at in that index is 5 then the two related jets are ParticleJets[5] and DetectableJets[0]
//
//  If a Detector Level Jet does not have a suitable pair then an index of -1 is given as an index
//
// PREREQUISITES
//  Constituent particles must be assigned a user index unique to the particle prior to jet clustering
//  These are set with the fastjet::PseudoJet set_user_index(Int_t) method.
//
//  UTK RHIP uses the naming convention of an index >= 0 is for a particle generated by the Monte Carlo (Pythia)
//  while an index < 0 is a particle from the background generator

#ifndef __CINT__
#include "TApplication.h"
#include "TMath.h"
#include "fastjet/PseudoJet.hh"
#include "fastjet/ClusterSequence.hh"
#include "fastjet/Selector.hh"
#include "UTKdefaults.h"
#endif

using namespace UTKdefaults;

// Internal structure for keeping track of prospective matches
struct Child {
	std::vector<Int_t> index;
	std::vector<Float_t> score;
};


class JetMatch {
public:
	JetMatch();
	static void GetIndices1to1ScoreMethod(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR);
	static void GetIndices1to1ScoreMethod2(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR);
	static void GetIndices1to1dRMethod(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR);
	static void GetIndices1to1PtMethod(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR);
	static Double_t GetdR(const fastjet::PseudoJet &jetA, const fastjet::PseudoJet &jetB);
	static Double_t GetdR2(const fastjet::PseudoJet &jetA, const fastjet::PseudoJet &jetB); //dR squared
	static Double_t GetDetectablePt(const std::vector<fastjet::PseudoJet> &particles);
	static Double_t GetOverlapPt(const std::vector<fastjet::PseudoJet> &particlesA,const std::vector<fastjet::PseudoJet> &particlesB);
	
	~JetMatch();
private:
	static void Insert(Child &childList,Int_t newchildindex, Float_t score);
	

};

// RelatedParticleJetIndex[detjet] = index of particle jet associated with detector level jet with index detjet

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetIndices(
//            const std::vector<fastjet::PseudoJet> &ParticleJets     // vector of particle level jets from fastjet
//            const std::vector<fastjet::PseudoJet> &DetectableJets   // vector of detector level jets from fastjet
//            std::vector<Int_t> &RelatedParticleJetIndex             // vector to be populated with index of associated particle level jet...
//                                                                    //   for detector level jet (see example below)
//            Float_t maxdR = UTKdefaults::matchR					  // maximum dR allowed between jets
//            );
void JetMatch::GetIndices1to1dRMethod(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR = UTKdefaults::matchR){
	Int_t NumJet_All = ParticleJets.size(); 
	Int_t NumJet_Detectable = DetectableJets.size();
	std::vector<Child> Children(NumJet_Detectable);
	
	Float_t matchRsquared = maxdR*maxdR;
	
	
	// Populate all dR matches
	
	if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	{
		// vectors of Constituent particles of jets
		
		std::vector<fastjet::PseudoJet> fjConstituentsDet; // vector (fj::pj) of Detectable particles
		std::vector<fastjet::PseudoJet> fjConstituentsAll; // vector (fj::pj) of All qualified particles
	
		// Detector level jet loop
		for (Int_t iDet = 0; iDet < NumJet_Detectable; iDet++)
		{
		
			fjConstituentsDet = DetectableJets[iDet].constituents();//get detector jet member particles
			Int_t nPartDet = fjConstituentsDet.size();
			
			// Particle level jet loop
			for (Int_t iAll = 0; iAll < NumJet_All; iAll++){
				
				// find square of dR
				Double_t dRs = GetdR2(ParticleJets[iAll],DetectableJets[iDet]);

				if (dRs <= matchRsquared){ // if within maxdR
				
					// find % overlap, (num of unique indexes found in both / number of particles in det level
					
					//Score the match
					Float_t matchScore = TMath::Sqrt(dRs);
					
					//Insert into list
					Insert(Children[iDet],iAll,matchScore);
				}
			} // Particle level jet loop
		
		}// Detector level jet loop
	
	
		// single iteration check for number of double claimed first position jets, bump jets to second position if better paired jets exist.
		// ***Not an ideal algorithm
		
		for (Int_t m = 0; m<NumJet_All;m++)
			{
			
			bool claimed = false;
			Int_t lastindex;
			for (Int_t n = 0; n<NumJet_Detectable;n++) // 
			{
				if (Children[n].index.size() !=0){
					
					if (Children[n].index[0] == m){
						
						if (claimed) {
							
							if (Children[n].score[0]<Children[lastindex].score[0]){
								
								Children[lastindex].score.erase(Children[lastindex].score.begin());
								Children[lastindex].index.erase(Children[lastindex].index.begin());
								lastindex = n;
							}
							else {
								
								Children[n].score.erase(Children[n].score.begin());
								Children[n].index.erase(Children[n].index.begin());
							}
						}
						else {
							
							claimed = true;
							lastindex = n;
						}
					}		
				}
			} // Detector level loop
		} //Duplicate check, Particle level loop
	} //if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	RelatedParticleJetIndex.resize(NumJet_Detectable);
	for (Int_t q = 0; q<NumJet_Detectable; q++){
		//set related particlejet index
		if (Children[q].index.size()!=0){
				RelatedParticleJetIndex[q] = Children[q].index[0];
		}
		else {
			RelatedParticleJetIndex[q] = -1;
		}
		
	}
}
	
void JetMatch::GetIndices1to1ScoreMethod(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR = UTKdefaults::matchR)
{
	Int_t NumJet_All = ParticleJets.size(); 
	Int_t NumJet_Detectable = DetectableJets.size();
	std::vector<Child> Children(NumJet_Detectable);
	
	Float_t matchRsquared = maxdR*maxdR;
	
	
	// Populate all dR matches
	
	if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	{
		// vectors of Constituent particles of jets
		
		std::vector<fastjet::PseudoJet> fjConstituentsDet; // vector (fj::pj) of Detectable particles
		std::vector<fastjet::PseudoJet> fjConstituentsAll; // vector (fj::pj) of All qualified particles
		
	
	
		// Detector level jet loop
		for (Int_t iDet = 0; iDet < NumJet_Detectable; iDet++)
		{
		
			fjConstituentsDet = DetectableJets[iDet].constituents();//get detector jet member particles
			Int_t nPartDet = fjConstituentsDet.size();
			
			// Particle level jet loop
			for (Int_t iAll = 0; iAll < NumJet_All; iAll++){
				
				// find square of dR
				Double_t dRs = GetdR2(ParticleJets[iAll],DetectableJets[iDet]);

				if (dRs <= matchRsquared){ // if within maxdR
				
					// find % overlap, (num of unique indexes found in both / number of particles in det level
					fjConstituentsAll = ParticleJets[iAll].constituents();
					Int_t nPartAll = fjConstituentsAll.size();
					Int_t indexAll, indexDet;
					Int_t overlap = 0;
					for (Int_t x = 0; x<nPartDet;x++)
					{
						indexDet = fjConstituentsDet[x].user_index();
						for (Int_t y = 0; y < nPartAll;y++){
							indexAll = fjConstituentsAll[y].user_index();
							if (indexAll == indexDet) overlap++;
						}
					}
					Float_t ratio = static_cast<Float_t>(overlap)/static_cast<Float_t>(nPartDet);
					
					//Score the match
					Float_t matchScore = (1-ratio)*TMath::Sqrt(dRs);
					
					//Insert into list
					Insert(Children[iDet],iAll,matchScore);
				}
			} // Particle level jet loop
		
		}// Detector level jet loop
	
	
		// single iteration check for number of double claimed first position jets, bump jets to second position if better paired jets exist.
		// ***Not an ideal algorithm
		
		for (Int_t m = 0; m<NumJet_All;m++)
			{
			
			bool claimed = false;
			Int_t lastindex;
			for (Int_t n = 0; n<NumJet_Detectable;n++) // 
			{
				if (Children[n].index.size() !=0){
					
					if (Children[n].index[0] == m){
						
						if (claimed) {
							
							if (Children[n].score[0]<Children[lastindex].score[0]){
								
								Children[lastindex].score.erase(Children[lastindex].score.begin());
								Children[lastindex].index.erase(Children[lastindex].index.begin());
								lastindex = n;
							}
							else {
								
								Children[n].score.erase(Children[n].score.begin());
								Children[n].index.erase(Children[n].index.begin());
							}
						}
						else {
							
							claimed = true;
							lastindex = n;
						}
					}		
				}
			} // Detector level loop
		} //Duplicate check, Particle level loop
	} //if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	RelatedParticleJetIndex.resize(NumJet_Detectable);
	for (Int_t q = 0; q<NumJet_Detectable; q++){
		//set related particlejet index
		if (Children[q].index.size()!=0){
				RelatedParticleJetIndex[q] = Children[q].index[0];
		}
		else {
			RelatedParticleJetIndex[q] = -1;
		}
		
	}
	
}
void JetMatch::GetIndices1to1ScoreMethod2(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR = UTKdefaults::matchR)
{
	Int_t NumJet_All = ParticleJets.size(); 
	Int_t NumJet_Detectable = DetectableJets.size();
	std::vector<Child> Children(NumJet_Detectable);
	
	Float_t matchRsquared = maxdR*maxdR;
	
	
	// Populate all dR matches
	
	if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	{
		// vectors of Constituent particles of jets
		
		std::vector<fastjet::PseudoJet> fjConstituentsDet; // vector (fj::pj) of Detectable particles
		std::vector<fastjet::PseudoJet> fjConstituentsAll; // vector (fj::pj) of All qualified particles
		
	
	
		// Detector level jet loop
		for (Int_t iDet = 0; iDet < NumJet_Detectable; iDet++)
		{
		
			fjConstituentsDet = DetectableJets[iDet].constituents();//get detector jet member particles
			Int_t nPartDet = fjConstituentsDet.size();
			
			// Particle level jet loop
			for (Int_t iAll = 0; iAll < NumJet_All; iAll++){
				
				// find square of dR
				Double_t dRs = GetdR2(ParticleJets[iAll],DetectableJets[iDet]);

				if (dRs <= matchRsquared){ // if within maxdR
				
					// find % overlap, (num of unique indexes found in both / number of particles in det level
					fjConstituentsAll = ParticleJets[iAll].constituents();
					Int_t nPartAll = fjConstituentsAll.size();
					Int_t indexAll, indexDet;
					Int_t overlap = 0;
					for (Int_t x = 0; x<nPartDet;x++)
					{
						indexDet = fjConstituentsDet[x].user_index();
						for (Int_t y = 0; y < nPartAll;y++){
							indexAll = fjConstituentsAll[y].user_index();
							if (indexAll == indexDet) overlap++;
						}
					}
					Float_t ratio = static_cast<Float_t>(2*overlap)/(static_cast<Float_t>(nPartDet)+static_cast<Float_t>(nPartDet));
					
					//Score the matchstd::vector<
					Float_t matchScore = (1-ratio)*TMath::Sqrt(dRs);
					
					//Insert into list
					if (overlap!=0)Insert(Children[iDet],iAll,matchScore);
				}
			} // Particle level jet loop
		
		}// Detector level jet loop
	
	
		// single iteration check for number of double claimed first position jets, bump jets to second position if better paired jets exist.
		// ***Not an ideal algorithm
		
		for (Int_t m = 0; m<NumJet_All;m++)
			{
			
			bool claimed = false;
			Int_t lastindex;
			for (Int_t n = 0; n<NumJet_Detectable;n++) // 
			{
				if (Children[n].index.size() !=0){
					
					if (Children[n].index[0] == m){
						
						if (claimed) {
							
							if (Children[n].score[0]<Children[lastindex].score[0]){
								
								Children[lastindex].score.erase(Children[lastindex].score.begin());
								Children[lastindex].index.erase(Children[lastindex].index.begin());
								lastindex = n;
							}
							else {
								
								Children[n].score.erase(Children[n].score.begin());
								Children[n].index.erase(Children[n].index.begin());
							}
						}
						else {
							
							claimed = true;
							lastindex = n;
						}
					}		
				}
			} // Detector level loop
		} //Duplicate check, Particle level loop
	} //if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	RelatedParticleJetIndex.resize(NumJet_Detectable);
	for (Int_t q = 0; q<NumJet_Detectable; q++){
		//set related particlejet index
		if (Children[q].index.size()!=0){
				RelatedParticleJetIndex[q] = Children[q].index[0];
		}
		else {
			RelatedParticleJetIndex[q] = -1;
		}
		
	}
	
}


void JetMatch::GetIndices1to1PtMethod(const std::vector<fastjet::PseudoJet> &ParticleJets, const std::vector<fastjet::PseudoJet> &DetectableJets, std::vector<Int_t> &RelatedParticleJetIndex, Float_t maxdR){
	Int_t NumJet_All = ParticleJets.size(); 
	Int_t NumJet_Detectable = DetectableJets.size();
	std::vector<Child> Children(NumJet_Detectable);
	
	Double_t matchRsquared = maxdR*maxdR;
	
	
	// Populate all dR matches
	
	if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	{
		// vectors of Constituent particles of jets
		
		std::vector<fastjet::PseudoJet> fjConstituentsDet; // vector (fj::pj) of Detectable particles
		std::vector<fastjet::PseudoJet> fjConstituentsAll; // vector (fj::pj) of All qualified particles
		
	
	
		// Detector level jet loop
		for (Int_t iDet = 0; iDet < NumJet_Detectable; iDet++)
		{
		
			fjConstituentsDet = DetectableJets[iDet].constituents();//get detector jet member particles
			Int_t nPartDet = fjConstituentsDet.size();
			
			// Particle level jet loop
			for (Int_t iAll = 0; iAll < NumJet_All; iAll++){
				
				// find square of dR
				Double_t dRs = GetdR2(ParticleJets[iAll],DetectableJets[iDet]);

				if (dRs <= matchRsquared){ // if within maxdR
				
					// find % overlap, (num of unique indexes found in both / number of particles in det level
					fjConstituentsAll = ParticleJets[iAll].constituents();
					Double_t PtDet =DetectableJets[iDet].perp();
					Double_t PtPartAdjusted; //PT of detectable particles in particle jet
					Double_t PtOverlap;
					
					Int_t nPartAll = fjConstituentsAll.size();
					Int_t indexAll, indexDet;
					
					PtPartAdjusted = GetDetectablePt(fjConstituentsAll);
					
					PtOverlap = GetOverlapPt(fjConstituentsDet,fjConstituentsAll);
					
					Float_t ratio = (2.0*PtOverlap)/(PtDet/PtPartAdjusted);
					
					//Score the match
					Float_t matchScore = (1.0-ratio);
					
					//Insert into list
					if (matchScore!=1.0) Insert(Children[iDet],iAll,matchScore);
				}
			} // Particle level jet loop
		
		}// Detector level jet loop
	
	
		// single iteration check for number of double claimed first position jets, bump jets to second position if better paired jets exist.
		// ***Not an ideal algorithm
		
		for (Int_t m = 0; m<NumJet_All;m++)
			{
			
			bool claimed = false;
			Int_t lastindex;
			for (Int_t n = 0; n<NumJet_Detectable;n++) // 
			{
				if (Children[n].index.size() !=0){
					
					if (Children[n].index[0] == m){
						
						if (claimed) {
							
							if (Children[n].score[0]<Children[lastindex].score[0]){
								
								Children[lastindex].score.erase(Children[lastindex].score.begin());
								Children[lastindex].index.erase(Children[lastindex].index.begin());
								lastindex = n;
							}
							else {
								
								Children[n].score.erase(Children[n].score.begin());
								Children[n].index.erase(Children[n].index.begin());
							}
						}
						else {
							
							claimed = true;
							lastindex = n;
						}
					}		
				}
			} // Detector level loop
		} //Duplicate check, Particle level loop
	} //if ( NumJet_Detectable != 0 && NumJet_All !=0) 
	RelatedParticleJetIndex.resize(NumJet_Detectable);
	for (Int_t q = 0; q<NumJet_Detectable; q++){
		//set related particlejet index
		if (Children[q].index.size()!=0){
				RelatedParticleJetIndex[q] = Children[q].index[0];
		}
		else {
			RelatedParticleJetIndex[q] = -1;
		}
		
	}
	
}
Double_t JetMatch::GetOverlapPt(const std::vector<fastjet::PseudoJet> &particlesA,const std::vector<fastjet::PseudoJet> &particlesB)
{
	Int_t nPartA = particlesA.size();
	Int_t nPartB = particlesB.size();
	Int_t indexA, indexB;
	
	Double_t PtOverlap = 0.0;
	
	for (Int_t x = 0; x<nPartA;x++)
	{
		indexA = particlesA[x].user_index();
		for (Int_t y = 0; y < nPartB;y++){
			indexB = particlesB[y].user_index();
			if (indexA == indexB) 
			{
				PtOverlap += particlesA[x].perp();
				break;
			}
		}
	}
	return PtOverlap;
}

Double_t JetMatch::GetDetectablePt(const std::vector<fastjet::PseudoJet> &particles){
	Double_t Pt = 0;
	Int_t nPart = particles.size();
	for (Int_t x = 0; x<nPart;x++)
	{
		if (particles[x].user_index() & DETECTABLE)
		{
			Pt += particles[x].perp();
		}
	}
	return Pt;
}


Double_t JetMatch::GetdR2(const fastjet::PseudoJet &jetA, const fastjet::PseudoJet &jetB){
	Double_t dR;
	Double_t etaA = jetA.eta();
	Double_t etaB = jetB.eta();
	Double_t phiA = jetA.phi();
	Double_t phiB = jetB.phi();
	Double_t dEta = etaB-etaA;
	Double_t dPhi = phiB-phiA;
	Double_t dPhiBorder;
	if (TMath::Abs(dPhi)>TMath::Pi())
	{
		if (phiA>phiB) {
			phiB += 2*TMath::Pi();
		}
		else phiA += 2*TMath::Pi();
		dPhi = phiB - phiA;
	}
	return (dPhi*dPhi + dEta*dEta);
	
	
}

Double_t JetMatch::GetdR(const fastjet::PseudoJet &jetA, const fastjet::PseudoJet &jetB){
	return (TMath::Sqrt(GetdR2(jetA,jetB)));
}
////////////////////////////////////////////////////////////////
// Insert(Child &childList,Int_t newchildindex, Float_t score);
//   Takes jet match candidate, compares score, and inserts into 
//   Child vector in order of increasing score.
void JetMatch::Insert(Child &childList,Int_t newchildindex, Float_t score)
{
	
	Int_t numChild = childList.index.size();
	Bool_t addtoend = true;
	if (numChild == 0) {
		childList.index.push_back(newchildindex);
		childList.score.push_back(score);
	}
	
	else {
		for (Int_t i = 0; i<numChild;i++){
			if (childList.score[i] > score) {
				addtoend = false;
				childList.index.insert(childList.index.begin() + i,newchildindex);
				childList.score.insert(childList.score.begin() + i,score);
				
			}
		}
		if (addtoend) {
			childList.index.push_back(newchildindex);
		    childList.score.push_back(score);
		}
	}
}

JetMatch::~JetMatch()
{
}

JetMatch::JetMatch()
{
}